rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {
    function isChatParticipant(slug, matchId) {
      return request.auth != null
        && exists(/databases/$(database)/documents/tournamentChats/$(slug)/matches/$(matchId))
        && request.auth.uid in get(/databases/$(database)/documents/tournamentChats/$(slug)/matches/$(matchId)).data.participants;
    }
    function isTournamentOwner(slug) {
      return request.auth != null
        && exists(/databases/$(database)/documents/tournaments/$(slug))
        && request.auth.uid == get(/databases/$(database)/documents/tournaments/$(slug)).data.createdBy;
    }
    function isCircuitOwner(circuitSlug) {
      return request.auth != null
        && circuitSlug != null
        && exists(/databases/$(database)/documents/tournamentCircuits/$(circuitSlug))
        && request.auth.uid == get(/databases/$(database)/documents/tournamentCircuits/$(circuitSlug)).data.createdBy;
    }
    function isCircuitOwnerForTournament(slug) {
      return request.auth != null
        && exists(/databases/$(database)/documents/tournaments/$(slug))
        && isCircuitOwner(get(/databases/$(database)/documents/tournaments/$(slug)).data.circuitSlug);
    }

    // ? USERS
    match /users/{userId} {
      allow read, write: if request.auth != null && request.auth.uid == userId;

      match /profile {
        allow read, write: if request.auth != null && request.auth.uid == userId;
      }

      match /builds/{buildId} {
        allow read, write: if request.auth != null && request.auth.uid == userId;
      }

      // ? BLOCKED USERS subcollection
      match /blockedUsers/{blockedUserId} {
        allow read: if request.auth != null && request.auth.uid == userId;
        allow create, delete: if request.auth != null && request.auth.uid == userId;
      }
    }

    // Private user templates
    match /users/{userId}/templates/{templateId} {
      allow read, write: if request.auth != null && request.auth.uid == userId;
    }

    // ? USERNAMES
    match /usernames/{username} {
      allow read: if true;

      allow create: if request.auth != null 
                    && request.auth.uid == request.resource.data.userId
                    && request.resource.data.keys().hasOnly(['userId']);

      allow delete: if request.auth != null 
                    && resource.data.userId == request.auth.uid;
    }

    // ? PUBLISHED BUILDS (shared to both public and clans)
    match /publishedBuilds/{buildId} {
      // ?? Everyone can read published builds
      allow read: if true;

      // ?? Create: only owner can publish their build
      allow write: if request.auth != null 
                   && request.auth.uid == request.resource.data.publisherId
                   && request.resource.data.keys().hasAny([
                        'title', 
                        'category', 
                        'subcategory', 
                        'publisherId', 
                        'username',
                        'isPublic',
                        'sharedToClans',
                        'timestamp'
                    ]);

      // ?? Update rules (voting/views)...
      allow update: if request.auth != null && (
        request.auth.uid == resource.data.publisherId ||
        (
          request.resource.data.diff(resource.data).changedKeys().hasOnly(["upvotes", "downvotes", "userVotes"]) &&
          request.resource.data.userVotes[request.auth.uid] in ["up", "down"] &&
          (
            request.resource.data.upvotes == resource.data.upvotes + 1 ||
            request.resource.data.downvotes == resource.data.downvotes + 1
          )
        ) ||
        (
          request.resource.data.diff(resource.data).changedKeys().hasOnly(["views"]) &&
          request.resource.data.views == resource.data.views + 1
        )
      );

      // ? Delete: only publisher can remove
      allow delete: if request.auth != null 
                    && request.auth.uid == resource.data.publisherId;

      // ? COMMENTS SUBCOLLECTION
      match /comments/{commentId} {
        allow read: if true;

        allow create: if request.auth != null
          && request.resource.data.userId == request.auth.uid
          && request.resource.data.text is string
          && request.resource.data.text.size() >= 2
          && request.resource.data.text.size() <= 1200
          && request.resource.data.timestamp == request.time;

        // ? Allow the comment author to edit only their own text
        allow update: if request.auth != null
          && request.auth.uid == resource.data.userId
          && request.resource.data.diff(resource.data).changedKeys().hasOnly(["text", "isEdited", "editedAt"]);

        allow delete: if request.auth != null
          && request.auth.uid == resource.data.userId;
      }

    }

    // ? CLANS
    match /clans/{clanId} {
      // ? Allow read of top-level clan data (for name, tag, logo, etc.)
      allow read: if true;

      // ? Create clan
      allow create: if request.auth != null &&
                    request.auth.uid == request.resource.data.adminUid &&
                    request.resource.data.members == [request.auth.uid] &&
                    request.resource.data.joinRequests == [] &&
                    request.resource.data.keys().hasAll([
                      'name',
                      'logoUrl',
                      'adminUid',
                      'members',
                      'joinRequests',
                      'created'
                    ]);

      // ?? Update: admin changes or member joining/leaving
      allow update: if request.auth != null && (

        // ? Admin can always update
        request.auth.uid == resource.data.adminUid ||

        // ? Member leaving (removing themselves from both members and memberInfo)
        (
          // Must have been a member before
          request.auth.uid in resource.data.members &&

          // Must not be in the updated members list
          !(request.auth.uid in request.resource.data.members) &&

          // Members count reduced by exactly 1
          request.resource.data.members.size() == resource.data.members.size() - 1 &&

          // memberInfo key removed
          !(request.auth.uid in request.resource.data.memberInfo) &&
          request.resource.data.memberInfo.size() == resource.data.memberInfo.size() - 1
        ) ||

        // ? Member joining via join request
        (
          request.resource.data.diff(resource.data).changedKeys().hasOnly(['joinRequests', 'memberInfo']) &&
          request.resource.data.memberInfo[request.auth.uid].requestedAt is int &&
          (
            !resource.data.memberInfo[request.auth.uid] ||  
            request.resource.data.memberInfo[request.auth.uid].requestedAt != null
          )
        )
      );




      // ? Delete: admin only
      allow delete: if request.auth != null &&
                    request.auth.uid == resource.data.adminUid;

      // ? CLAN BUILDS (subcollection)
      match /builds/{buildId} {
        allow read: if request.auth != null &&
                    request.auth.uid in get(/databases/$(database)/documents/clans/$(clanId)).data.members;

        allow create: if request.auth != null &&
                      request.auth.uid in get(/databases/$(database)/documents/clans/$(clanId)).data.members;

        allow update: if request.auth != null &&
                      (
                        request.auth.uid == resource.data.ownerUid ||
                        request.auth.uid == get(/databases/$(database)/documents/clans/$(clanId)).data.adminUid
                      );

        allow delete: if request.auth != null &&
                      (
                        request.auth.uid == resource.data.ownerUid ||
                        request.auth.uid == get(/databases/$(database)/documents/clans/$(clanId)).data.adminUid
                      );
      }
    }

    // ? TOURNAMENTS
    match /tournaments/{slug} {
      // Public read; adjust to restrict if needed
      allow read: if true;

      // Any signed-in user can create
      allow create: if request.auth != null;

      // Only creator can update/delete
      allow update: if request.auth != null &&
        request.auth.uid == resource.data.createdBy;
      allow delete: if request.auth != null && (
        request.auth.uid == resource.data.createdBy ||
        isCircuitOwner(resource.data.circuitSlug)
      );
    }

    // ? TOURNAMENT STATE (players, bracket, activity)
    match /tournamentStates/{slug} {
      // Allow public reads (adjust if you want private)
      allow read: if true;
      // Allow signed-in users to sync state; tighten if needed
      allow write: if request.auth != null;
    }

    // ? TOURNAMENT INVITE LINKS (token-based access for closed tournaments)
    match /tournamentInviteLinks/{slug}/links/{token} {
      // Anyone with the URL token can verify it.
      allow get: if true;
      // Only the tournament owner can list/create/revoke links.
      allow list, create, delete: if isTournamentOwner(slug) || isCircuitOwnerForTournament(slug);
      // Owner can update anything; invited users can only consume a link (uses +1).
      allow update: if isTournamentOwner(slug) || isCircuitOwnerForTournament(slug) || (
        request.auth != null &&
        request.resource.data.diff(resource.data).changedKeys().hasOnly(["uses", "lastUsedAt"]) &&
        request.resource.data.uses == resource.data.uses + 1 &&
        request.resource.data.lastUsedAt is int
      );
    }

    // ? TOURNAMENT CIRCUITS
    match /tournamentCircuits/{slug} {
      allow read: if true;
      allow create: if request.auth != null;
      allow update, delete: if request.auth != null &&
        request.auth.uid == resource.data.createdBy;
    }

    // ? TOURNAMENT PRESENCE (lightweight UI presence)
    match /tournamentPresence/{slug}/matchInfo/{uid} {
      allow read: if true;
      allow create, update: if request.auth != null && request.auth.uid == uid;
      allow delete: if request.auth != null && (
        request.auth.uid == uid ||
        isTournamentOwner(slug) ||
        isCircuitOwnerForTournament(slug)
      );
    }

    // ? TOURNAMENT MATCH CHAT
    match /tournamentChats/{slug}/matches/{matchId} {
      allow read: if request.auth != null && (
        request.auth.uid in resource.data.participants ||
        isTournamentOwner(slug) ||
        isCircuitOwnerForTournament(slug)
      );
      allow create: if request.auth != null
        && request.resource.data.participants is list
        && request.auth.uid in request.resource.data.participants
        && request.resource.data.participants.size() <= 25
        && request.resource.data.keys().hasOnly(["participants", "updatedAt"]);
      allow update: if request.auth != null
        && (request.auth.uid in resource.data.participants ||
            request.auth.uid in request.resource.data.participants)
        && request.resource.data.participants is list
        && request.resource.data.participants.size() <= 25
        && request.resource.data.participants.hasAll(resource.data.participants)
        && request.resource.data.keys().hasOnly(["participants", "updatedAt"]);
      allow delete: if isTournamentOwner(slug) || isCircuitOwnerForTournament(slug);

      match /messages/{messageId} {
        allow read: if isChatParticipant(slug, matchId)
          || isTournamentOwner(slug)
          || isCircuitOwnerForTournament(slug);
        allow create: if request.auth != null
          && request.resource.data.keys().hasOnly(["text", "uid", "name", "createdAt", "clientCreatedAt"])
          && request.resource.data.text is string
          && request.resource.data.text.size() >= 1
          && request.resource.data.text.size() <= 500
          && request.resource.data.uid == request.auth.uid
          && isChatParticipant(slug, matchId);
        allow update: if false;
        allow delete: if isTournamentOwner(slug) || isCircuitOwnerForTournament(slug);
      }
    }

    // ? USER NOTIFICATIONS
    match /users/{userId}/notifications/{notificationId} {
      allow read: if request.auth != null && request.auth.uid == userId;
      allow create: if request.auth != null
        && request.resource.data.userId is string
        && request.resource.data.userId == userId
        && request.resource.data.senderUid == request.auth.uid;
      allow update, delete: if request.auth != null && request.auth.uid == userId;
    }

  }
}
